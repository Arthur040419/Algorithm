package algorithm;

//96.不同的二叉搜索树
public class LeetCode96 {
    public int numTrees(int n) {
        /**
         * 思路：
         * 这题做起来有点有点让人不那么好理解
         * 假如要求节点个数为n的不同二叉搜索树的个数
         * 那么这个二叉搜索树首先要拿一个节点来作为根节点，然后剩下的节点作为左右子树
         * 例如左子树可以分配i个节点，那么右子树就可以分配n-i-1个节点
         * 在这种情况下，不同的二叉搜索树的个数为节点数为i的不同二叉树个数乘以节点数为n-i-1的不同二叉树个数
         * 假设dp[i]代表i个节点的不同二叉搜素树个数，那么dp[n] = dp[i]*dp[n-i-1]
         * 于是就可以有下面的步骤：
         * 1.定义dp数组，dp[i]表示i个节点的不同二叉搜索树个数
         * 2.确定递推公式，dp[i] = dp[j]*dp[i-j-1]   0<=j<=i-1
         * 3.初始化dp数组，dp[0]=1,dp[1]=1
         * 4.确定遍历顺序，从小到大遍历
         */

        //定义dp数组
        int[] dp = new int[n+1];
        
        //初始化dp数组
        dp[0]=1;
        dp[1]=1;
        
        //遍历dp数组
        for (int i = 2; i < n+1; i++) {
            for (int j = 0; j <= i-1; j++) {
                dp[i]+=dp[j]*dp[i-j-1];
            }
        }

        return dp[n];
    }
}
